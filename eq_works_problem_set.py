# -*- coding: utf-8 -*-
"""EQ Works Problem Set.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x0wpfOTM27GyZ05i7eyofhitq-5bHZsn
"""

#Import all the data

#Import pandas and the data
import pandas as pd 
import numpy as np
import math
import statistics
from sklearn import preprocessing

data= pd.read_csv("https://raw.githubusercontent.com/EQWorks/ws-data-spark/master/data/DataSample.csv")
POI_List= pd.read_csv("https://raw.githubusercontent.com/EQWorks/ws-data-spark/master/data/POIList.csv")

# -------- PART 1: CLEANUP --------------#
data.drop_duplicates(subset=['Country','Province','City','Latitude','Longitude'],keep=False, inplace=True)
print('Dataframe size after removing geoclean duplicates:') 
print(len(data))
data.drop_duplicates(subset=[' TimeSt'],keep=False, inplace=True)
print('Dataframe size after removing timestamp duplicates:', len(data)) 
new_data=data.reset_index(drop='True')



# --------- PART 2: LABEL ------------#
Lat=new_data['Latitude']
Long=new_data['Longitude']

POI_Data=pd.DataFrame(columns=['POI Number','Distance','Latitude','Longitude'])

for i in range(0,len(new_data)):
  Distance=[0]*4
  for j in range (0,len(POI_List)):
    Lat0=Lat[i]-POI_List.loc[j,' Latitude']
    Long0=Long[i]-POI_List.loc[j,'Longitude']
    Distance[j]= math.sqrt(Lat0**2 + Long0**2)
    
  min=np.min(Distance) #Multiple points can have identical distances to a given POI
  for k in range(0,len(POI_List)):
    if (min== Distance[k]): 
      new_row0=[k,min,Lat[i],Long[i]]
      POI_Data.loc[len(POI_Data)]=new_row0

POI_Data.drop_duplicates(subset=['Distance'],keep='first', inplace=True) #first 2 POI's are idenical. All points will be assigned to 0, and 1 will remain empty
POI_Data=POI_Data.reset_index(drop='True')
print(POI_Data)

#---------------PART 3: ANALYSIS ----------------#


mean=[0]*4
sd=[0]*4

for i in range (0,len(POI_List)):
  POI= POI_Data.loc[POI_Data['POI Number']==i,'Distance']
  length=len(POI_Data.loc[POI_Data['POI Number']==i,'Distance'])
  
  if (length >0):
    mean[i]=sum(POI)/length
    sd[i]=statistics.stdev(POI)
    print('POI Number:', i, 'Mean:', mean[i],'Standard Deviation:', sd[i])
  if (length==0):
    mean[i]='DNE'
    sd[i]='DNE'
    print('POI Number:', i, 'Mean:', mean[i],'Standard Deviation:', sd[i])

#--------------- PART 3: ANALYSIS CONTINUED--------------------#

# At each POI, draw a circle (with the center at the POI) that includes all of its assigned requests
import matplotlib.pyplot as plt
import math

def circle(i):
  POI_Lat= POI_List.loc[i,' Latitude']
  POI_Long= POI_List.loc[i,'Longitude']

  Data=POI_Data.loc[POI_Data['POI Number']==i]
  Lat_Max=abs(POI_Data.loc[POI_Data['POI Number']==i,'Latitude'].max())
  Long_Max=abs(POI_Data.loc[POI_Data['POI Number']==i,'Longitude'].max())
  print('LATMAX:', Lat_Max)
  print('LongMax:', Long_Max)
 
  if (Lat_Max > Long_Max):
    radius=abs(Lat_Max-POI_Lat)
  else:
    radius=abs(Long_Max-POI_Long)

  circle_0=plt.Circle((POI_Lat,POI_Long), radius, color='grey')
  POI_Data.loc[POI_Data['POI Number']==i].plot.scatter(x='Latitude',y='Longitude')
  ax=plt.gca()
  ax.add_patch(circle_0)
  plt.axis("scaled")
  plt.show()

#Calculate the Density and Area
  area=math.pi*radius**2
  density=len(Data)/area #edit

  print('POI:', i, '\nArea:', area, '\nDensity:', density)
  return(area,density)

for i in range(0,len(POI_List)):
  circle(i)

#-----------------PART 4A: MODEL ------------------#


#Latitude
def model(i):
  norm_Lat=POI_Data.loc[POI_Data['POI Number']==i,'Latitude']
  norm_Long=POI_Data.loc[POI_Data['POI Number']==i,'Longitude']

  x=np.interp(norm_Lat, (norm_Lat.min(),norm_Lat.max()), (-10,10))
  x1=np.interp(norm_Long, (norm_Long.min(),norm_Long.max()), (-10,10))

  z_lat=np.abs(stats.zscore(x))
  z_long= np.abs(stats.zscore(x1))

  noo_lat=np.where(z_lat<3)
  noo_long=np.where(z_long<3)
  
  Scaled_Data=pd.DataFrame(columns=['Scaled Latitude', 'Scaled Longitude'])
  
  for i in range (0,len(norm_Lat)):
    if (z_lat[i]<3):
      if (z_long[i] <3):
        new_row=[x[i],x1[i]]
        Scaled_Data.loc[len(Scaled_Data)]=new_row

  noo_lat= Scaled_Data['Scaled Latitude']
  noo_long=Scaled_Data['Scaled Longitude']
  
  plt.scatter(x=noo_lat, y=noo_long)
  plt.title('Scaled Data without Outliers')

model(0)
model(1)
model(2)
model(3)