# -*- coding: utf-8 -*-
"""EQ Works Problem Set.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x0wpfOTM27GyZ05i7eyofhitq-5bHZsn
"""

#Import all the data

#Import pandas and the data
import pandas as pd 
import numpy as np
import math
import statistics

data= pd.read_csv("https://raw.githubusercontent.com/EQWorks/ws-data-spark/master/data/DataSample.csv")
POI_List= pd.read_csv("https://raw.githubusercontent.com/EQWorks/ws-data-spark/master/data/POIList.csv")

# -------- PART 1: CLEANUP --------------#
data.drop_duplicates(subset=['Country','Province','City','Latitude','Longitude'],keep=False, inplace=True)
print('Dataframe size after removing geoclean duplicates:') 
print(len(data))
data.drop_duplicates(subset=[' TimeSt'],keep=False, inplace=True)
print('Dataframe size after removing timestamp duplicates:', len(data)) 
new_data=data.reset_index(drop='True')



# --------- PART 2: LABEL ------------#
Lat=new_data['Latitude']
Long=new_data['Longitude']

POI_Data=pd.DataFrame(columns=['POI Number','Distance','Latitude','Longitude'])

for i in range(0,len(new_data)):
  Distance=[0]*4
  for j in range (0,len(POI_List)):
    Lat0=Lat[i]-POI_List.loc[j,' Latitude']
    Long0=Long[i]-POI_List.loc[j,'Longitude']
    Distance[j]= math.sqrt(Lat0**2 + Long0**2)
    
  min=np.min(Distance) #Multiple points can have identical distances to a given POI
  for k in range(0,len(POI_List)):
    if (min== Distance[k]): 
      new_row0=[k,min,Lat[i],Long[i]]
      POI_Data.loc[len(POI_Data)]=new_row0

POI_Data.drop_duplicates(subset=['Distance'],keep='first', inplace=True) #first 2 POI's are idenical. All points will be assigned to 0, and 1 will remain empty
POI_Data=POI_Data.reset_index(drop='True')
print(POI_Data)

#---------------PART 3: ANALYSIS ----------------#


mean=[0]*4
sd=[0]*4

for i in range (0,len(POI_List)):
  POI= POI_Data.loc[POI_Data['POI Number']==i,'Distance']
  length=len(POI_Data.loc[POI_Data['POI Number']==i,'Distance'])
  
  if (length >0):
    mean[i]=sum(POI)/length
    sd[i]=statistics.stdev(POI)
    print('POI Number:', i, 'Mean:', mean[i],'Standard Deviation:', sd[i])
  if (length==0):
    mean[i]='DNE'
    sd[i]='DNE'
    print('POI Number:', i, 'Mean:', mean[i],'Standard Deviation:', sd[i])

#--------------- PART 3: ANALYSIS CONTINUED--------------------#

# At each POI, draw a circle (with the center at the POI) that includes all of its assigned requests
import matplotlib.pyplot as plt
import math

def circle(i):
  POI_Lat= POI_List.loc[i,' Latitude']
  POI_Long= POI_List.loc[i,'Longitude']

  Data=POI_Data.loc[POI_Data['POI Number']==i]
  Lat_Max=abs(POI_Data.loc[POI_Data['POI Number']==i,'Latitude'].max())
  Long_Max=abs(POI_Data.loc[POI_Data['POI Number']==i,'Longitude'].max())
  print('LATMAX:', Lat_Max)
  print('LongMax:', Long_Max)
 
  if (Lat_Max > Long_Max):
    radius=abs(Lat_Max-POI_Lat)
  else:
    radius=abs(Long_Max-POI_Long)

  circle_0=plt.Circle((POI_Lat,POI_Long), radius, color='grey')
  POI_Data.loc[POI_Data['POI Number']==i].plot.scatter(x='Latitude',y='Longitude')
  ax=plt.gca()
  ax.add_patch(circle_0)
  plt.axis("scaled")
  plt.show()

#Calculate the Density and Area
  area=math.pi*radius**2
  density=len(Data)/area #edit

  print('POI:', i, '\nArea:', area, '\nDensity:', density)
  return(area,density)

for i in range(0,len(POI_List)):
  circle(i)

#-----------------PART 4A: MODEL ------------------#

#standardization 

#Latitude
for i in range(0,len(POI_List)):
  S_Lat= POI_Data.loc[POI_Data['POI Number']==i,'Latitude']
  S_Long=POI_Data.loc[POI_Data['POI Number']==i,'Longitude']

  S_lat_length=len(S_Lat)
  S_long_length=len(S_Long)
  
  if (S_lat_length>0 and S_lat_length>0 ):
    SLat_mean=sum(S_Lat)/S_lat_length
    SLong_mean=sum(S_Long)/S_long_length

    SLat_sd=statistics.stdev(S_Lat)
    SLong_sd=statistics.stdev(S_Long)

    stan_Lat=(S_Lat-SLat_mean)/SLat_sd
    stan_Long=(S_Long-SLong_mean)/SLong_sd
  else:
    stan_Lat==0
    stan_Long==0
  plt.scatter(x=stan_Lat, y=stan_Long)